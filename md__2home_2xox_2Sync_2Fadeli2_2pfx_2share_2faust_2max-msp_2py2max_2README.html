<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Faust architecture: py2max</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Faust architecture
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">py2max</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md394"></a> A pure python3 library without dependencies intended to facilitate the offline generation of Max patcher files (<code>.maxpat</code>, <code>.maxhelp</code>, <code>.rbnopat</code>).</p>
<p>If you are looking for python3 externals for Max/MSP check out the <a href="https://github.com/shakfu/py-js">py-js</a> project.</p>
<h1><a class="anchor" id="autotoc_md395"></a>
Features</h1>
<ul>
<li>Scripted <em>offline</em> generation of Max patcher files using Python objects, corresponding, on a one-to-one basis, with Max/MSP objects stored in the <code>.maxpat</code> JSON-based file format.</li>
<li><em>Round-trip conversion</em> between (JSON) <code>.maxpat</code> files with arbitrary levels of nesting and corresponding <code>Patcher</code>, <code>Box</code>, and <code>Patchline</code> Python objects.</li>
<li>Can potentially handle any Max object or maxclass.</li>
<li>Lots of unit tests, ~99% coverage.</li>
<li>Analysis and offline scripted modification of Max patches in terms of composition, structure (as graphs of objects), object properties and layout (using graph-drawing algorithms).</li>
<li>Allows precise layout and configuration of Max objects.</li>
<li><code>Patcher</code> objects have generic methods such as <code>add_textbox</code> and can also have specialized methods such as <code>add_coll</code>. As an example, this method has a <code>dictionary</code> argument to make it easy to prepopulate the <code>coll</code> object (see <code>py2max/tests/test_coll.py</code>).</li>
<li>Provides a <code>maxclassdb</code> feature which recalls default configurations of Max Objects.</li>
</ul>
<h1><a class="anchor" id="autotoc_md396"></a>
Possible use cases</h1>
<ul>
<li>Scripted patcher file creation.</li>
<li>Batch modification of existing .maxpat files.</li>
<li>Use the rich python standard library and ecosystem to help create parametrizable objects with configuration from offline sources. For example, one-of-a-kind wavetable oscillators configured from random wavetable files.</li>
<li>Generation of test cases and <code>.maxhelp</code> files during external development</li>
<li>Takes the pain out of creating objects with lots of parameters</li>
<li>Prepopulate containers objects such as <code>coll</code>, <code>dict</code> and <code>table</code> objects with data</li>
<li>Help to save time creating many objects with slightly different arguments</li>
<li>Use <a class="el" href="md__2home_2xox_2Sync_2Fadeli2_2pfx_2share_2faust_2max-msp_2py2max_2docs_2auto-layouts.html">graph drawing / layout algorithms</a> on generated patches.</li>
<li>Generative patch generation <code>(-;</code></li>
<li>etc..</li>
</ul>
<h1><a class="anchor" id="autotoc_md397"></a>
Usage examples</h1>
<div class="fragment"><div class="line">p = Patcher(<span class="stringliteral">&#39;my-patch.maxpat&#39;</span>)</div>
<div class="line">osc1 = p.add_textbox(<span class="stringliteral">&#39;cycle~ 440&#39;</span>)</div>
<div class="line">gain = p.add_textbox(<span class="stringliteral">&#39;gain~&#39;</span>)</div>
<div class="line">dac = p.add_textbox(<span class="stringliteral">&#39;ezdac~&#39;</span>)</div>
<div class="line">osc1_gain = p.add_line(osc1, gain)</div>
<div class="line">gain_dac0 = p.add_line(gain, outlet=0, dac, inlet=0)</div>
<div class="line">gain_dac1 = p.add_line(gain, outlet=0, dac, inlet=1)</div>
<div class="line">p.save()</div>
</div><!-- fragment --><p>By default, objects are returned (including patchlines), and patchline outlets and inlets are set to 0. While returned objects are useful for linking, the returned patchlines are not. Therefore, the above can be written more concisely as:</p>
<div class="fragment"><div class="line">p = Patcher(<span class="stringliteral">&#39;my-patch.maxpat&#39;</span>)</div>
<div class="line">osc1 = p.add_textbox(<span class="stringliteral">&#39;cycle~ 440&#39;</span>)</div>
<div class="line">gain = p.add_textbox(<span class="stringliteral">&#39;gain~&#39;</span>)</div>
<div class="line">dac = p.add_textbox(<span class="stringliteral">&#39;ezdac~&#39;</span>)</div>
<div class="line">p.add_line(osc1, gain)</div>
<div class="line">p.add_line(gain, dac)</div>
<div class="line">p.add_line(gain, dac, inlet=1)</div>
<div class="line">p.save()</div>
</div><!-- fragment --><p>With builtin aliases (<code>.add</code> for <code>.add_*</code> type methods and <code>.link</code> for <code>.add_line</code>), the above example can be written in an even more abbreviated form (and with a vertical layout) as:</p>
<div class="fragment"><div class="line">p = Patcher(<span class="stringliteral">&#39;out_vertical.maxpat&#39;</span>, layout=<span class="stringliteral">&#39;vertical&#39;</span>)</div>
<div class="line">osc = p.add(<span class="stringliteral">&#39;cycle~ 440&#39;</span>)</div>
<div class="line">gain = p.add(<span class="stringliteral">&#39;gain~&#39;</span>)</div>
<div class="line">dac = p.add(<span class="stringliteral">&#39;ezdac~&#39;</span>)</div>
<div class="line">p.link(osc, gain)</div>
<div class="line">p.link(gain, dac)</div>
<div class="line">p.link(gain, dac, 1)</div>
<div class="line">p.save()</div>
</div><!-- fragment --><p>In addition, you can parse existing <code>.maxpat</code> files, change them and then save the changes:</p>
<div class="fragment"><div class="line">p = Patcher.from_file(<span class="stringliteral">&#39;example1.maxpat&#39;</span>)</div>
<div class="line"><span class="comment"># ... make some change</span></div>
<div class="line">p.save_as(<span class="stringliteral">&#39;example1_mod.maxpat&#39;</span>)</div>
</div><!-- fragment --><p>Another example with subpatchers:</p>
<div class="fragment"><div class="line">p = Patcher(<span class="stringliteral">&#39;out.maxpat&#39;</span>)</div>
<div class="line">sbox = p.add_subpatcher(<span class="stringliteral">&#39;p mysub&#39;</span>)</div>
<div class="line">sp = sbox.subpatcher</div>
<div class="line">in1 = sp.add(<span class="stringliteral">&#39;inlet&#39;</span>)</div>
<div class="line">gain = sp.add(<span class="stringliteral">&#39;gain~&#39;</span>)</div>
<div class="line">out1 = sp.add(<span class="stringliteral">&#39;outlet&#39;</span>)</div>
<div class="line">osc = p.add(<span class="stringliteral">&#39;cycle~ 440&#39;</span>)</div>
<div class="line">dac = p.add(<span class="stringliteral">&#39;ezdac~&#39;</span>)</div>
<div class="line">sp.link(in1, gain)</div>
<div class="line">sp.link(gain, out1)</div>
<div class="line">p.link(osc, sbox)</div>
<div class="line">p.link(sbox, dac)</div>
<div class="line">p.save()</div>
</div><!-- fragment --><p>Note that Python classes are basically just simple wrappers around the JSON structures in a .maxpat file, and almost all Max/MSP and Jitter objects can be added to the patcher file with the <code>.add_textbox</code> or the generic <code>.add</code> methods. There are also specialized methods in the form <code>.add_&lt;type&gt;</code> for numbers, numeric parameters, subpatchers, and container-type objects (see the design notes below for more details).</p>
<h1><a class="anchor" id="autotoc_md398"></a>
Installation</h1>
<p>Simplest way:</p>
<div class="fragment"><div class="line">git https://github.com/shakfu/py2max.git</div>
<div class="line">cd py2max</div>
<div class="line">pip install . # optional</div>
</div><!-- fragment --><p>Note that py2max does not need to be installed to be used, so you can skip the <code>pip install .</code> part if you prefer and just <code>cd</code> into the cloned directory and start using it:</p>
<div class="fragment"><div class="line">$ cd py2max</div>
<div class="line">$ ipython</div>
<div class="line"> </div>
<div class="line">In [1]: from py2max import Patcher</div>
<div class="line"> </div>
<div class="line">In [2]: p = Patcher.from_file(&quot;tests/data/simple.maxpat&quot;)</div>
<div class="line"> </div>
<div class="line">In [3]: p._boxes</div>
<div class="line">Out[3]: [Box(id=&#39;obj-2&#39;, maxclass=&#39;ezdac~&#39;), Box(id=&#39;obj-1&#39;, maxclass=&#39;newobj&#39;)]</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md399"></a>
Testing</h1>
<p><code>py2max</code> has an extensive test suite with tests are in the <code>py2max/tests</code> folder.</p>
<p>One can run all tests as follows:</p>
<div class="fragment"><div class="line">pytest</div>
</div><!-- fragment --><p>This will output the results of all tests into <code>outputs</code> folder.</p>
<p>Note that some tests may be skipped if a required package for the test cannot be imported.</p>
<p>You can check which test is skipped by the following:</p>
<div class="fragment"><div class="line">pytest -v</div>
</div><!-- fragment --><p>To check test coverage:</p>
<div class="fragment"><div class="line">./scripts/coverage.sh</div>
</div><!-- fragment --><p>which essentially does the following</p>
<div class="fragment"><div class="line">mkdir -p outputs</div>
<div class="line">pytest --cov-report html:outputs/_covhtml --cov=py2max tests</div>
</div><!-- fragment --><p>To run an individual test:</p>
<div class="fragment"><div class="line">python3 -m pytest tests.test_basic</div>
</div><!-- fragment --><p>Note that because <code>py2max</code> primarily deals with <code>json</code> generation and manipulation, most tests have no dependencies since <code>json</code> is already built into the stdlib.</p>
<p>However, a bunch of tests explore the application of orthogonal graph layout algorithms and for this, a whole bunch of packages have been used, which range from the well-known to the esoteric.</p>
<p>As mentioned above, pytest will skip a test if required packages are not installed, so these are entirely optional tests.</p>
<p>If you insist on diving into the rabbit hole, and want to run all tests you will need the following packages (and their dependencies):</p>
<ul>
<li><a href="https://networkx.org">networkx</a>: <code>pip install networkx</code></li>
<li><a href="https://matplotlib.org">matplotlib</a>: <code>pip install matplotlib</code></li>
<li><a href="https://github.com/pygraphviz/pygraphviz">pygraphviz</a>: Pygraphviz requires installing the development library of graphviz: <a href="https://www.graphviz.org/">https://www.graphviz.org/</a> (On macOS this can be done via <code>brew install graphviz</code>) &ndash; then you can <code>pip install pygraphviz</code></li>
<li><a href="https://github.com/mjwybrow/adaptagrams">adaptagrams</a>: First build the adaptagrams c++ libs and then build the swig-based python wrapper.</li>
<li><a href="https://github.com/shakfu">pyhola</a>: a pybind11 wrapper of adaptagrams. Follow build instructions in the README and install from the git repo.</li>
<li><a href="https://github.com/uknfire/tsmpy">tsmpy</a>: install from git repo</li>
<li><a href="https://github.com/hasii2011/OrthogonalDrawing">OrthogonalDrawing</a>: install from git repo</li>
</ul>
<h1><a class="anchor" id="autotoc_md400"></a>
Caveats</h1>
<ul>
<li>API Docs are still not available</li>
<li>The current default layout algorithm is extremely rudimentary, however there are some <a class="el" href="md__2home_2xox_2Sync_2Fadeli2_2pfx_2share_2faust_2max-msp_2py2max_2docs_2notes_2graph-drawing.html">promising directions</a> and you can see also see a <a class="el" href="md__2home_2xox_2Sync_2Fadeli2_2pfx_2share_2faust_2max-msp_2py2max_2docs_2auto-layouts.html">visual comparison</a> of how well different layout algorithms perform in this context.</li>
<li>While generation does not consume the py2max objects, Max does not unfortunately refresh-from-file when it's open, so you will have to keep closing and reopening Max to see the changes to the object tree.</li>
<li><p class="startli">For the few objects which have their own methods, the current implementation differentiates tilde objects from non-tilde objects by providing a different method with a <code>_tilde</code> suffix:</p>
<div class="fragment"><div class="line">gen = p.add_gen()</div>
<div class="line"> </div>
<div class="line">gen_tilde = p.add_gen_tilde()</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md401"></a>
Design Notes</h1>
<p>The <code>.maxpat</code> JSON format is actually pretty minimal and hierarchical. It has a parent <code>Patcher</code> and child <code>Box</code> entries and also <code>Patchlines</code>. Certain boxes contain other <code>patcher</code> instances to represent nested subpatchers and <code>gen~</code> patches, etc..</p>
<p>The above structure directly maps onto the Python implementation which consists of 3 classes: <code>Patcher</code>, <code>Box</code>, and <code>Patchline</code>. These classes are extendable via their respective <code>**kwds</code> and internal<code>__dict__</code> structures. In fact, this is the how the <code>.from_file</code> patcher classmethod is implemented.</p>
<p>This turns out to be the most maintainable and flexible way to handle all the differences between the hundreds of Max, MSP, and Jitter objects.</p>
<p>A growing list of patcher methods have been implemented to specialize and facilitate the creation of certain classes of objects which require additional configuration:</p>
<ul>
<li><code>.add_attr</code></li>
<li><code>.add_beap</code></li>
<li><code>.add_bpatcher</code></li>
<li><code>.add_codebox</code></li>
<li><code>.add_coll</code></li>
<li><code>.add_comment</code></li>
<li><code>.add_dict</code></li>
<li><code>.add_floatbox</code></li>
<li><code>.add_floatparam</code></li>
<li><code>.add_gen</code></li>
<li><code>.add_intbox</code></li>
<li><code>.add_intparam</code></li>
<li><code>.add_itable</code></li>
<li><code>.add_message</code></li>
<li><code>.add_rnbo</code></li>
<li><code>.add_subpatcher</code></li>
<li><code>.add_table</code></li>
<li><code>.add_textbox</code></li>
<li><code>.add_umenu</code></li>
</ul>
<p>This is a short list, but the <code>add_textbox</code> method alone can handle almost all case. The others are really just there for convenience and to save typing.</p>
<p>Generally, it is recommended to start using <code>py2max</code>'s via these <code>add_&lt;type&gt;</code> methods, since they have most of the required parameters built into the methods and you can get IDE completion support. Once you are comfortable with the parameters, then use the generic abbreviated form: <code>add</code>, which is less typing but tbe tradeoff is you lose the IDE parameter completion support.</p>
<h1><a class="anchor" id="autotoc_md402"></a>
Scripts</h1>
<p>The project has a few of scripts which may be useful:</p>
<ul>
<li><code>convert.py</code>: convert <code>maxpat</code> to <code>yaml</code> for ease of reading during dev</li>
<li><code>compare.py</code>: compare using <a href="https://zepworks.com/deepdiff/current/diff.html">deepdiff</a></li>
<li><code>coverage.sh</code>: run pytest coverage and generate html coverage report</li>
</ul>
<p>Note that if you want to build py2max as a wheel:</p>
<div class="fragment"><div class="line">pip install build</div>
<div class="line">cd py2max</div>
<div class="line">python3 -m build .</div>
</div><!-- fragment --><p>The wheel then should be in the <code>dist</code> directory.</p>
<h1><a class="anchor" id="autotoc_md403"></a>
Examples of Use</h1>
<ul>
<li><a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/max-msp/rnbo.py">Generate Max patchers for faust2rnbo</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md404"></a>
Credits and Licensing</h1>
<p>All rights reserved to the original respective authors:</p>
<ul>
<li>Steve Kieffer, Tim Dwyer, Kim Marriott, and Michael Wybrow. HOLA: Human-like Orthogonal Network Layout. In Visualization and Computer Graphics, IEEE Transactions on, Volume 22, Issue 1, pages 349 - 358. IEEE, 2016. DOI</li>
<li>Aric A. Hagberg, Daniel A. Schult and Pieter J. Swart, “Exploring network structure, dynamics, and function using NetworkX”, in Proceedings of the 7th Python in Science Conference (SciPy2008), Gäel Varoquaux, Travis Vaught, and Jarrod Millman (Eds), (Pasadena, CA USA), pp. 11–15, Aug 2008</li>
<li>A Technique for Drawing Directed Graphs Emden R. Gansner, Eleftherios Koutsofios, Stephen C. North, Kiem-phong Vo • IEEE TRANSACTIONS ON SOFTWARE ENGINEERING • Published 1993</li>
<li>Gansner, E.R., Koren, Y., North, S. (2005). Graph Drawing by Stress Majorization. In: Pach, J. (eds) Graph Drawing. GD 2004. Lecture Notes in Computer Science, vol 3383. Springer, Berlin, Heidelberg. <a href="https://doi.org/10.1007/978-3-540-31843-9_25">https://doi.org/10.1007/978-3-540-31843-9_25</a></li>
<li>An open graph visualization system and its applications to software engineering Emden R. Gansner, Stephen C. North • SOFTWARE - PRACTICE AND EXPERIENCE • Published 2000 </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
