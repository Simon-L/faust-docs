<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Faust architecture: Adding Oboe to your project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Faust architecture
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Adding Oboe to your project</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md99"></a>There are two ways use Oboe in your Android Studio project:</p>
<p>1) <b>Use the Oboe pre-built library binaries and headers</b>. Use this approach if you just want to use a stable version of the Oboe library in your project.</p>
<p>or</p>
<p>2) <b>Build Oboe from source.</b> Use this approach if you would like to debug or make changes to the Oboe source code and contribute back to the project.</p>
<h1><a class="anchor" id="autotoc_md100"></a>
Option 1) Using pre-built binaries and headers</h1>
<p>Oboe is distributed as a <a href="https://github.com/google/prefab">prefab</a> package via <a href="https://maven.google.com/web/index.html">Google Maven</a> (search for "oboe"). <a href="https://android-developers.googleblog.com/2020/02/native-dependencies-in-android-studio-40.html">Prefab support was added</a> to <a href="https://developer.android.com/studio/preview">Android Studio Preview 4.0 Canary 9</a> so you'll need to be using this version of Android Studio or above.</p>
<p>Add the oboe dependency to your app's <code>build.gradle</code> file. Replace "1.6.0" with the <a href="https://github.com/google/oboe/releases/">latest stable version</a> of Oboe: </p><pre class="fragment">dependencies {
    implementation 'com.google.oboe:oboe:1.6.0'
}
</pre><p> Also enable prefab by adding: </p><pre class="fragment">android {
    buildFeatures {
        prefab true
    }
}
</pre><p> Include and link to oboe by updating your <code>CMakeLists.txt</code>: </p><pre class="fragment">find_package (oboe REQUIRED CONFIG)
target_link_libraries(native-lib oboe::oboe) # You may have other libraries here such as `log`.
</pre><p> Here's a complete example <code>CMakeLists.txt</code> file: </p><pre class="fragment">cmake_minimum_required(VERSION 3.4.1)

# Build our own native library
add_library (native-lib SHARED native-lib.cpp )

# Find the Oboe package
find_package (oboe REQUIRED CONFIG)

# Specify the libraries which our native library is dependent on, including Oboe
target_link_libraries(native-lib log oboe::oboe)
</pre><p> Configure your app to use the shared STL by updating your <code>app/build.gradle</code>: </p><pre class="fragment">android { 
    defaultConfig { 
        externalNativeBuild {
            cmake {
                arguments "-DANDROID_STL=c++_shared"
            }
        }
    }
}
</pre> <h1><a class="anchor" id="autotoc_md101"></a>
Option 2) Building from source</h1>
<h2><a class="anchor" id="autotoc_md102"></a>
1. Clone the github repository</h2>
<p>Start by cloning the <a href="https://github.com/google/oboe/releases/">latest stable release</a> of the Oboe repository, for example: </p><pre class="fragment">git clone -b 1.6-stable https://github.com/google/oboe
</pre><p> <b>Make a note of the path which you cloned oboe into - you will need it shortly</b></p>
<p>If you use git as your version control system, consider adding Oboe as a <a href="https://gist.github.com/gitaarik/8735255">submodule</a> (underneath your cpp directory)</p>
<div class="fragment"><div class="line">git submodule add https://github.com/google/oboe</div>
</div><!-- fragment --><p>This makes it easier to integrate updates to Oboe into your app, as well as contribute to the Oboe project.</p>
<h2><a class="anchor" id="autotoc_md103"></a>
2. Update CMakeLists.txt</h2>
<p>Open your app's <code>CMakeLists.txt</code>. This can be found under <code>External Build Files</code> in the Android project view. If you don't have a <code>CMakeLists.txt</code> you will need to <a href="https://developer.android.com/studio/projects/add-native-code">add C++ support to your project</a>.</p>
<p><img src="images/cmakelists-location-in-as.png" alt="CMakeLists.txt location in Android Studio" title="CMakeLists.txt location in Android Studio" class="inline"/></p>
<p>Now add the following commands to the end of <code>CMakeLists.txt</code>. <b>Remember to update <code>**PATH TO OBOE**</code> with your local Oboe path from the previous step</b>: </p><pre class="fragment"># Set the path to the Oboe directory.
set (OBOE_DIR ***PATH TO OBOE***)

# Add the Oboe library as a subdirectory in your project.
# add_subdirectory tells CMake to look in this directory to
# compile oboe source files using oboe's CMake file.
# ./oboe specifies where the compiled binaries will be stored
add_subdirectory (${OBOE_DIR} ./oboe)

# Specify the path to the Oboe header files.
# This allows targets compiled with this CMake (application code)
# to see public Oboe headers, in order to access its API.
include_directories (${OBOE_DIR}/include)
</pre><p>In the same file find the <a href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html"><code>target_link_libraries</code></a> command. Add <code>oboe</code> to the list of libraries which your app's library depends on. For example: </p><pre class="fragment">target_link_libraries(native-lib oboe)
</pre><p> Here's a complete example <code>CMakeLists.txt</code> file: </p><pre class="fragment">cmake_minimum_required(VERSION 3.4.1)

# Build our own native library
add_library (native-lib SHARED native-lib.cpp )

# Build the Oboe library
set (OBOE_DIR ./oboe)
add_subdirectory (${OBOE_DIR} ./oboe)

# Make the Oboe public headers available to our app
include_directories (${OBOE_DIR}/include)

# Specify the libraries which our native library is dependent on, including Oboe
target_link_libraries (native-lib log oboe)
</pre><p>Now go to <code>Build-&gt;Refresh Linked C++ Projects</code> to have Android Studio index the Oboe library.</p>
<p>Verify that your project builds correctly. If you have any issues building please <a href="issues/new">report them here</a>.</p>
<h1><a class="anchor" id="autotoc_md104"></a>
Using Oboe</h1>
<p>Once you've added Oboe to your project you can start using Oboe's features. The simplest, and probably most common thing you'll do in Oboe is to create an audio stream.</p>
<h2><a class="anchor" id="autotoc_md105"></a>
Creating an audio stream</h2>
<p>Include the Oboe header: </p><pre class="fragment">#include &lt;oboe/Oboe.h&gt;
</pre><p> Streams are built using an <code>AudioStreamBuilder</code>. Create one like this: </p><pre class="fragment">oboe::AudioStreamBuilder builder;
</pre><p> Use the builder's set methods to set properties on the stream (you can read more about these properties in the <a class="el" href="md__2home_2xox_2Sync_2Fadeli2_2pfx_2share_2faust_2android_2app_2oboe_2docs_2FullGuide.html">full guide</a>): </p><pre class="fragment">builder.setDirection(oboe::Direction::Output);
builder.setPerformanceMode(oboe::PerformanceMode::LowLatency);
builder.setSharingMode(oboe::SharingMode::Exclusive);
builder.setFormat(oboe::AudioFormat::Float);
builder.setChannelCount(oboe::ChannelCount::Mono);
</pre><p> The builder's set methods return a pointer to the builder. So they can be easily chained:</p>
<div class="fragment"><div class="line">oboe::AudioStreamBuilder builder;</div>
<div class="line">builder.setPerformanceMode(oboe::PerformanceMode::LowLatency)</div>
<div class="line">  -&gt;setSharingMode(oboe::SharingMode::Exclusive)</div>
<div class="line">  -&gt;setDataCallback(myCallback)</div>
<div class="line">  -&gt;setFormat(oboe::AudioFormat::Float);</div>
</div><!-- fragment --><p>Define an <code>AudioStreamDataCallback</code> class to receive callbacks whenever the stream requires new data. </p><pre class="fragment">class MyCallback : public oboe::AudioStreamDataCallback {
public:
    oboe::DataCallbackResult
    onAudioReady(oboe::AudioStream *audioStream, void *audioData, int32_t numFrames) {

        // We requested AudioFormat::Float. So if the stream opens
    // we know we got the Float format.
        // If you do not specify a format then you should check what format
        // the stream has and cast to the appropriate type.
        auto *outputData = static_cast&lt;float *&gt;(audioData);

        // Generate random numbers (white noise) centered around zero.
        const float amplitude = 0.2f;
        for (int i = 0; i &lt; numFrames; ++i){
            outputData[i] = ((float)drand48() - 0.5f) * 2 * amplitude;
        }

        return oboe::DataCallbackResult::Continue;
    }
};
</pre><p> You can find examples of how to play sound using digital synthesis and pre-recorded audio in the <a href="../samples">code samples</a>.</p>
<p>Declare your callback somewhere that it won't get deleted while you are using it. </p><pre class="fragment">MyCallback myCallback;
</pre><p> Supply this callback class to the builder: </p><pre class="fragment">builder.setDataCallback(&amp;myCallback);
</pre><p> Declare a shared pointer for the stream. Make sure it is declared with the appropriate scope. The best place is as a member variable in a managing class or as a global. Avoid declaring it as a local variable because the stream may get deleted when the function returns. </p><pre class="fragment">std::shared_ptr&lt;oboe::AudioStream&gt; mStream;
</pre><p> Open the stream: </p><pre class="fragment">oboe::Result result = builder.openStream(mStream);
</pre><p> Check the result to make sure the stream was opened successfully. Oboe has a convenience method for converting its types into human-readable strings called <code><a class="el" href="namespaceoboe.html#a0310f9ed27a82c4b9859beb938737096">oboe::convertToText</a></code>: </p><pre class="fragment">if (result != oboe::Result::OK) {
    LOGE("Failed to create stream. Error: %s", oboe::convertToText(result));
}
</pre><p> Note that this sample code uses the <a href="https://github.com/googlesamples/android-audio-high-performance/blob/master/debug-utils/logging_macros.h">logging macros from here</a>.</p>
<h2><a class="anchor" id="autotoc_md106"></a>
Playing audio</h2>
<p>Check the properties of the created stream. If you did not specify a channelCount, sampleRate, or format then you need to query the stream to see what you got. The <b>format</b> property will dictate the <code>audioData</code> type in the <code>AudioStreamDataCallback::onAudioReady</code> callback. If you did specify any of those three properties then you will get what you requested. </p><pre class="fragment">oboe::AudioFormat format = mStream-&gt;getFormat();
LOGI("AudioStream format is %s", oboe::convertToText(format));
</pre><p> Now start the stream. </p><pre class="fragment">mStream-&gt;requestStart();
</pre><p> At this point you should start receiving callbacks.</p>
<p>To stop receiving callbacks call </p><pre class="fragment">mStream-&gt;requestStop();
</pre> <h2><a class="anchor" id="autotoc_md107"></a>
Closing the stream</h2>
<p>It is important to close your stream when you're not using it to avoid hogging audio resources which other apps could use. This is particularly true when using <code>SharingMode::Exclusive</code> because you might prevent other apps from obtaining a low latency audio stream.</p>
<p>Streams should be explicitly closed when the app is no longer playing audio. </p><pre class="fragment">mStream-&gt;close();
</pre><p> <code>close()</code> is a blocking call which also stops the stream.</p>
<p>For apps which only play or record audio when they are in the foreground this is usually done when <a href="https://developer.android.com/guide/components/activities/activity-lifecycle#onpause"><code>Activity.onPause()</code></a> is called.</p>
<h2><a class="anchor" id="autotoc_md108"></a>
Reconfiguring streams</h2>
<p>After closing, in order to change the configuration of the stream, simply call <code>openStream</code> again. The existing stream is deleted and a new stream is built and populates the <code>mStream</code> variable. </p><div class="fragment"><div class="line">// Modify the builder with some additional properties at runtime.</div>
<div class="line">builder.setDeviceId(MY_DEVICE_ID);</div>
<div class="line">// Re-open the stream with some additional config</div>
<div class="line">// The old AudioStream is automatically deleted</div>
<div class="line">builder.openStream(mStream);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md109"></a>
Example</h2>
<p>The following class is a complete implementation of an audio player that renders a sine wave. </p><div class="fragment"><div class="line">#include &lt;oboe/Oboe.h&gt;</div>
<div class="line">#include &lt;math.h&gt;</div>
<div class="line"> </div>
<div class="line">class OboeSinePlayer: public oboe::AudioStreamDataCallback {</div>
<div class="line">public:</div>
<div class="line"> </div>
<div class="line">    virtual ~OboeSinePlayer() = default;</div>
<div class="line"> </div>
<div class="line">    // Call this from Activity onResume()</div>
<div class="line">    int32_t startAudio() {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mLock);</div>
<div class="line">        oboe::AudioStreamBuilder builder;</div>
<div class="line">        // The builder set methods can be chained for convenience.</div>
<div class="line">        Result result = builder.setSharingMode(oboe::SharingMode::Exclusive)</div>
<div class="line">                -&gt;setPerformanceMode(oboe::PerformanceMode::LowLatency)</div>
<div class="line">                -&gt;setChannelCount(kChannelCount)</div>
<div class="line">                -&gt;setSampleRate(kSampleRate)</div>
<div class="line">        -&gt;setSampleRateConversionQuality(oboe::SampleRateConversionQuality::Medium);</div>
<div class="line">                -&gt;setFormat(oboe::AudioFormat::Float)</div>
<div class="line">                -&gt;setDataCallback(this)</div>
<div class="line">                -&gt;openStream(mStream);</div>
<div class="line">    if (result != Result::OK) return (int32_t) result;</div>
<div class="line">    </div>
<div class="line">        // Typically, start the stream after querying some stream information, as well as some input from the user</div>
<div class="line">        result = outStream-&gt;requestStart();</div>
<div class="line">    return (int32_t) result;</div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">    // Call this from Activity onPause()</div>
<div class="line">    void stopAudio() {</div>
<div class="line">        // Stop, close and delete in case not already closed.</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mLock);</div>
<div class="line">        if (mStream) {</div>
<div class="line">            mStream-&gt;stop();</div>
<div class="line">            mStream-&gt;close();</div>
<div class="line">            mStream.reset();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    oboe::DataCallbackResult onAudioReady(oboe::AudioStream *oboeStream, void *audioData, int32_t numFrames) override {</div>
<div class="line">        float *floatData = (float *) audioData;</div>
<div class="line">        for (int i = 0; i &lt; numFrames; ++i) {</div>
<div class="line">            float sampleValue = kAmplitude * sinf(mPhase);</div>
<div class="line">            for (int j = 0; j &lt; kChannelCount; j++) {</div>
<div class="line">                floatData[i * kChannelCount + j] = sampleValue;</div>
<div class="line">            }</div>
<div class="line">            mPhase += mPhaseIncrement;</div>
<div class="line">            if (mPhase &gt;= kTwoPi) mPhase -= kTwoPi;</div>
<div class="line">        }</div>
<div class="line">        return oboe::DataCallbackResult::Continue;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    std::mutex         mLock;</div>
<div class="line">    std::shared_ptr&lt;oboe::AudioStream&gt; mStream;</div>
<div class="line"> </div>
<div class="line">    // Stream params</div>
<div class="line">    static int constexpr kChannelCount = 2;</div>
<div class="line">    static int constexpr kSampleRate = 48000;</div>
<div class="line">    // Wave params, these could be instance variables in order to modify at runtime</div>
<div class="line">    static float constexpr kAmplitude = 0.5f;</div>
<div class="line">    static float constexpr kFrequency = 440;</div>
<div class="line">    static float constexpr kPI = M_PI;</div>
<div class="line">    static float constexpr kTwoPi = kPI * 2;</div>
<div class="line">    static double constexpr mPhaseIncrement = kFrequency * kTwoPi / (double) kSampleRate;</div>
<div class="line">    // Keeps track of where the wave is</div>
<div class="line">    float mPhase = 0.0;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note that this implementation computes sine values at run-time for simplicity, rather than pre-computing them. Additionally, best practice is to implement a separate data callback class, rather than managing the stream and defining its data callback in the same class.</p>
<p>For more examples on how to use Oboe look in the <a href="https://github.com/google/oboe/tree/master/samples">samples</a> folder.</p>
<h2><a class="anchor" id="autotoc_md110"></a>
Obtaining optimal latency</h2>
<p>One of the goals of the Oboe library is to provide low latency audio streams on the widest range of hardware configurations. When a stream is opened using AAudio, the optimal rate will be chosen unless the app requests a specific rate. The framesPerBurst is also provided by AAudio.</p>
<p>But OpenSL ES cannot determine those values. So applications should query them using Java and then pass them to Oboe. They will be used for OpenSL ES streams on older devices.</p>
<p>Here's a code sample showing how to set these default values.</p>
<p><em>MainActivity.java</em> </p><pre class="fragment">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1){
    AudioManager myAudioMgr = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
    String sampleRateStr = myAudioMgr.getProperty(AudioManager.PROPERTY_OUTPUT_SAMPLE_RATE);
    int defaultSampleRate = Integer.parseInt(sampleRateStr);
    String framesPerBurstStr = myAudioMgr.getProperty(AudioManager.PROPERTY_OUTPUT_FRAMES_PER_BUFFER);
    int defaultFramesPerBurst = Integer.parseInt(framesPerBurstStr);

    native_setDefaultStreamValues(defaultSampleRate, defaultFramesPerBurst);
}
</pre><p> <em>jni-bridge.cpp</em> </p><pre class="fragment">JNIEXPORT void JNICALL
Java_com_google_sample_oboe_hellooboe_MainActivity_native_1setDefaultStreamValues(JNIEnv *env,
                                                                                  jclass type,
                                                                                  jint sampleRate,
                                                                                  jint framesPerBurst) {
    oboe::DefaultStreamValues::SampleRate = (int32_t) sampleRate;
    oboe::DefaultStreamValues::FramesPerBurst = (int32_t) framesPerBurst;
}
</pre><p> Note that the values from Java are for built-in audio devices. Peripheral devices, such as Bluetooth may need larger framesPerBurst.</p>
<h1><a class="anchor" id="autotoc_md111"></a>
Further information</h1>
<ul>
<li><a href="https://github.com/google/oboe/tree/master/samples">Code samples</a></li>
<li><a class="el" href="md__2home_2xox_2Sync_2Fadeli2_2pfx_2share_2faust_2android_2app_2oboe_2docs_2FullGuide.html">Full guide to Oboe</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
