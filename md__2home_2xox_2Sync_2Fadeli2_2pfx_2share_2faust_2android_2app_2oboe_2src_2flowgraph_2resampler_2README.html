<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Faust architecture: Sample Rate Converter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Faust architecture
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Sample Rate Converter</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md211"></a> This folder contains a sample rate converter, or "resampler".</p>
<p>The converter is based on a sinc function that has been windowed by a hyperbolic cosine. We found this had fewer artifacts than the more traditional Kaiser window.</p>
<h1><a class="anchor" id="autotoc_md212"></a>
Building the Resampler</h1>
<p>It is part of <a href="https://github.com/google/oboe">Oboe</a> but has no dependencies on Oboe. So the contents of this folder can be used outside of Oboe.</p>
<p>To build it for use outside of Oboe:</p>
<ol type="1">
<li>Copy the "resampler" folder to a folder in your project that is in the include path.</li>
<li>Add all of the *.cpp files in the resampler folder to your project IDE or Makefile.</li>
</ol>
<h1><a class="anchor" id="autotoc_md213"></a>
Creating a Resampler</h1>
<p>Include the <a href="MultiChannelResampler.h">main header</a> for the resampler. </p><pre class="fragment">#include "resampler/MultiChannelResampler.h"
</pre><p> Here is an example of creating a stereo resampler that will convert from 44100 to 48000 Hz. Only do this once, when you open your stream. Then use the sample resampler to process multiple buffers. </p><pre class="fragment">MultiChannelResampler *resampler = MultiChannelResampler::make(
        2, // channel count
        44100, // input sampleRate
        48000, // output sampleRate
        MultiChannelResampler::Quality::Medium); // conversion quality
</pre><p> Possible values for quality include { Fastest, Low, Medium, High, Best }. Higher quality levels will sound better but consume more CPU because they have more taps in the filter.</p>
<h1><a class="anchor" id="autotoc_md214"></a>
Fractional Frame Counts</h1>
<p>Note that the number of output frames generated for a given number of input frames can vary.</p>
<p>For example, suppose you are converting from 44100 Hz to 48000 Hz and using an input buffer with 960 frames. If you calculate the number of output frames you get: </p><pre class="fragment">960 * 48000 * 44100 = 1044.897959...
</pre><p> You cannot generate a fractional number of frames. So the resampler will sometimes generate 1044 frames and sometimes 1045 frames. On average it will generate 1044.897959 frames. The resampler stores the fraction internally and keeps track of when to consume or generate a frame.</p>
<p>You can either use a fixed number of input frames or a fixed number of output frames. The other frame count will vary.</p>
<h1><a class="anchor" id="autotoc_md215"></a>
Calling the Resampler with a fixed number of OUTPUT frames</h1>
<p>In this example, suppose we have a fixed number of output frames and a variable number of input frames.</p>
<p>Assume you start with these variables and a method that returns the next input frame: </p><pre class="fragment">float *outputBuffer;     // multi-channel buffer to be filled
int    numOutputFrames;  // number of frames of output
</pre><p> The resampler has a method isWriteNeeded() that tells you whether to write to or read from the resampler. </p><pre class="fragment">int outputFramesLeft = numOutputFrames;
while (outputFramesLeft &gt; 0) {
    if(resampler-&gt;isWriteNeeded()) {
        const float *frame = getNextInputFrame(); // you provide this
        resampler-&gt;writeNextFrame(frame);
    } else {
        resampler-&gt;readNextFrame(outputBuffer);
        outputBuffer += channelCount;
        outputFramesLeft--;
    }
}
</pre> <h1><a class="anchor" id="autotoc_md216"></a>
Calling the Resampler with a fixed number of INPUT frames</h1>
<p>In this example, suppose we have a fixed number of input frames and a variable number of output frames.</p>
<p>Assume you start with these variables: </p><pre class="fragment">float *inputBuffer;     // multi-channel buffer to be consumed
float *outputBuffer;    // multi-channel buffer to be filled
int    numInputFrames;  // number of frames of input
int    numOutputFrames = 0;
int    channelCount;    // 1 for mono, 2 for stereo

int inputFramesLeft = numInputFrames;
while (inputFramesLeft &gt; 0) {
    if(resampler-&gt;isWriteNeeded()) {
        resampler-&gt;writeNextFrame(inputBuffer);
        inputBuffer += channelCount;
        inputFramesLeft--;
    } else {
        resampler-&gt;readNextFrame(outputBuffer);
        outputBuffer += channelCount;
        numOutputFrames++;
    }
}
</pre> <h1><a class="anchor" id="autotoc_md217"></a>
Deleting the Resampler</h1>
<p>When you are done, you should delete the Resampler to avoid a memory leak. </p><pre class="fragment">delete resampler;
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
